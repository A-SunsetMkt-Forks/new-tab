import { debounce, onClick } from '../helpers';

class {
  onCreate() {
    this.state = {
      search: '',
      tabsRaw: [],
      tabs: [],
      bookmarksRaw: [],
      bookmarks: [],
      historyRaw: [],
      history: [],
    };
    this.lastSearch = '';

    this.search = debounce(this.doSearch, 200);

    this.getTabs();
  }

  onMount() {
    // update tab list on tab events
    chrome.tabs.onUpdated.addListener((tabId, changeInfo) => {
      if (changeInfo.title !== undefined) {
        this.getTabs();
      }
    });
    chrome.tabs.onMoved.addListener(() => this.getTabs());
    chrome.tabs.onRemoved.addListener(() => this.getTabs());

    // bring focus to search input on click
    const el = this.getEl('i');
    this.subscribeTo(window).on('click', () => el.focus());
  }

  onRender() {
    if (this.state.search !== this.lastSearch) {
      this.search();
    }
  }

  doSearch() {
    const { search } = this.state;

    this.lastSearch = search;

    // reset search when input is empty
    if (search === '') {
      this.state.tabs = this.state.tabsRaw;
      this.state.bookmarks.length = 0;
      this.state.history.length = 0;
      return;
    }

    // search history (run first since it takes the longest)
    chrome.history.search({ text: search }, (results) => {
      this.state.historyRaw = results;
      this.state.history = this.state.historyRaw.slice(0, 10);
    });

    // search bookmarks
    chrome.bookmarks.search(search, (results) => {
      this.state.bookmarksRaw = results;
      this.state.bookmarks = this.state.bookmarksRaw.slice(0, 10);
    });

    // search open tabs
    this.state.tabs = this.state.tabsRaw.filter(item =>
        item.title.toLowerCase().indexOf(search) > -1 ||
        item.url.toLowerCase().indexOf(search) > -1);
  }

  getTabs() {
    chrome.tabs.query({}, (tabs) => {
      this.state.tabsRaw = tabs;

      if (this.state.search === '') {
        this.state.tabs = tabs;
      }
    });
  }

  onTabClick(tab, event) {
    // update current tab
    chrome.tabs.update(tab.id, { active: true });

    // switch active window if the tab isn't in the current window
    chrome.windows.getCurrent({}, currentWindow => {
      if (currentWindow.id !== tab.windowId) {
        chrome.windows.update(tab.windowId, { focused: true });
      }
    });

    // close this tab
    chrome.tabs.getCurrent((tab) => {
      chrome.tabs.remove(tab.id);
    });

    event.preventDefault();
  }

  cancelSearch(event) {
    if (event.key === 'Escape') {
      this.state.search = '';
      this.state.tabs = this.state.tabs;
      this.state.bookmarks.length = 0;
      this.state.history.length = 0;
    }
  }

  loadMore(key, rawList, length) {
    this.setState(key, rawList.slice(0, length + 100));
  }
}

style {
  .c { /* container */
    max-width: 60rem;
    padding: 0 18px;
    margin: 0 auto;
  }

  #s { /* search */
    width: 100%;
    padding: 11px 20px;
    margin: 0 0 18px;
    font-size: 22px;
    color: var(--g5);
    background: var(--g2);
    border: 0;
    filter: drop-shadow(0 5px 6px rgba(0,0,0,0.1));
  }

  .r { /* search result */
    display: flex;
    align-items: center;
    white-space: nowrap;
    padding: 9px 0;
    overflow: hidden;
    color: var(--g-light);

    & > .i {
      padding-right: 9px;
    }
  }

  button {
    padding: 9px 18px;
    font-size: 20px;
    color: var(--g5);
    background: var(--g2);
    border: 0;
  }
}

$ let isSearching = state.search !== '';

macro itemList(title, list, rawList, key)
  $ let count = list.length;
  $ let length = rawList.length;

  if(count)
    h2 -- ${title} (${count}/${length})

    for(item in list)
      a.r on-click(onClick) key=key+item.id href=item.url
        img.i src=`chrome://favicon/${item.url}`
        -- ${item.title || item.url}

    if(count < length)
      button.f on-click('loadMore', title, rawList, count) -- Show more...
  else-if(isSearching)
    p.g -- No matching ${title}

div.c
  input#s on-keyup('cancelSearch') bind('search') key="i" type="text" placeholder="Search tabs, bookmarks, and history..." autocomplete="off"

  <!-- Open Tabs -->
  $ let tabsCount = state.tabs.length;
  if(tabsCount)
    h2 -- open tabs (${tabsCount}/${state.tabsRaw.length})

    for(tab in state.tabs)
      a.r on-click('onTabClick', tab) key='t'+tab.id href=tab.url
        img.i src=tab.favIconUrl

        -- ${tab.title}
  else-if(isSearching)
    p.g -- No matching open tabs

  <!-- Bookmarks -->
  itemList('bookmarks', state.bookmarks, state.bookmarksRaw, 'b')

  <!-- History -->
  itemList('history', state.history, state.historyRaw, 'h')
