import { debounce, onClick } from '../helpers';

class {
  onCreate() {
    this.state = {
      search: '', // don't __mangle; used with bind()
      __tabsRaw: [],
      __tabs: [],
      __bookmarksRaw: [],
      __bookmarks: [],
      __historyRaw: [],
      __history: [],
    };
    this.__lastSearch = '';
    this.__search = debounce(this.__doSearch, 200);

    this.__getTabs();
  }

  onMount() {
    // update tab list on tab events
    chrome.tabs.onUpdated.addListener((tabId, changeInfo) => {
      if (changeInfo.title !== undefined) {
        this.__getTabs();
      }
    });
    chrome.tabs.onMoved.addListener(() => this.__getTabs());
    chrome.tabs.onRemoved.addListener(() => this.__getTabs());

    // bring focus to search input on click
    const el = this.getEl('i');
    this.subscribeTo(window).on('click', () => el.focus());
  }

  onRender() {
    if (this.state.search !== this.__lastSearch) {
      this.__search();
    }
  }

  __doSearch() {
    const { search } = this.state;

    this.__lastSearch = search;

    // reset search when input is empty
    if (search === '') {
      this.state.__tabs = this.state.__tabsRaw;
      this.state.__bookmarks.length = 0;
      this.state.__history.length = 0;
      return;
    }

    // search history (run first since it takes the longest)
    chrome.history.search({ text: search }, (results) => {
      this.state.__historyRaw = results;
      this.state.__history = this.state.__historyRaw.slice(0, 10);
    });

    // search bookmarks
    chrome.bookmarks.search(search, (results) => {
      this.state.__bookmarksRaw = results;
      this.state.__bookmarks = this.state.__bookmarksRaw.slice(0, 10);
    });

    // search open tabs
    this.state.__tabs = this.state.__tabsRaw.filter(item =>
        item.title.toLowerCase().indexOf(search) > -1 ||
        item.url.toLowerCase().indexOf(search) > -1);
  }

  __getTabs() {
    chrome.tabs.query({}, (tabs) => {
      this.state.__tabsRaw = tabs;

      if (this.state.search === '') {
        this.state.__tabs = tabs;
      }
    });
  }

  onTabClick(tab, event) {
    // update current tab
    chrome.tabs.update(tab.id, { active: true });

    // switch active window if the tab isn't in the current window
    chrome.windows.getCurrent({}, currentWindow => {
      if (currentWindow.id !== tab.windowId) {
        chrome.windows.update(tab.windowId, { focused: true });
      }
    });

    // close this NTP
    chrome.tabs.getCurrent((tab) => {
      chrome.tabs.remove(tab.id);
    });

    event.preventDefault();
  }

  cancelSearch(event) {
    if (event.key === 'Escape') {
      this.state.search = '';
      this.state.__tabs = this.state.__tabs;
      this.state.__bookmarks.length = 0;
      this.state.__history.length = 0;
    }
  }

  // loadMore(key, rawList, length) {
  //   this.state[key] = rawList.slice(0, length + 100);
  // }
  // FIXME: Set state (dynamic key)
  loadMore(list, rawList, length) {
    console.log('##', list);
    list = rawList.slice(0, length + 100);
  }
}

style {
  .c { /* container */
    max-width: 60rem;
    padding: 0 18px;
    margin: 0 auto;
  }

  #s { /* search */
    width: 100%;
    padding: 11px 20px;
    margin: 0 0 18px;
    font-size: 22px;
    color: var(--g5);
    background: var(--g2);
    border: 0;
    filter: drop-shadow(0 5px 6px rgba(0,0,0,0.1));
  }

  .r { /* search result */
    display: flex;
    align-items: center;
    white-space: nowrap;
    padding: 9px 0;
    overflow: hidden;
    color: var(--g-light);

    & > .i {
      padding-right: 9px;
    }
  }

  button {
    padding: 9px 18px;
    font-size: 20px;
    color: var(--g5);
    background: var(--g2);
    border: 0;
  }
}

$ let isSearching = state.search !== '';

macro itemList(title, list, rawList, key)
  $ let count = list.length;
  $ let length = rawList.length;

  if(count)
    h2 -- ${title} (${count}/${length})

    for(item in list)
      a.r on-click(onClick) key=key+item.id href=item.url
        img.i src=`chrome://favicon/${item.url}`
        -- ${item.title || item.url}

    if(count < length)
      // button.f on-click('loadMore', title, rawList, count) -- Show more...
      button.f on-click('loadMore', list, rawList, count) -- Show more...
  else-if(isSearching)
    p.g -- No matching ${title}

div.c
  input#s on-keyup('cancelSearch') bind('search') key="i" type="text" placeholder="Search tabs, bookmarks, and history..." autocomplete="off"

  <!-- Open Tabs -->
  $ let tabsCount = state.__tabs.length;
  if(tabsCount)
    h2 -- open tabs (${tabsCount}/${state.__tabsRaw.length})

    for(tab in state.__tabs)
      a.r on-click('onTabClick', tab) key='t'+tab.id href=tab.url
        img.i src=tab.favIconUrl

        -- ${tab.title}
  else-if(isSearching)
    p.g -- No matching open tabs

  <!-- Bookmarks -->
  itemList('bookmarks', state.__bookmarks, state.__bookmarksRaw, 'b')

  <!-- History -->
  itemList('history', state.__history, state.__historyRaw, 'h')
