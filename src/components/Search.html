<!-- bring focus to search input when clicking anywhere -->
<svelte:window on:click="refs.s.focus()"/>

<div class="container">
  <input
    id="search"
    bind:value="_search"
    ref:s
    placeholder="Search browser..."
    autocomplete="off"
    on:keyup="_cancelSearch(event.key)"
  >

  <!-- Open Tabs -->
  {#if _tabs.length}
    <h2>Open Tabs ({_tabs.length}/{_tabsRaw.length})</h2>

    {#each _tabs as _item (_item.id)}
      <a href="{_item.url}" class="result" on:click="_onTabClick(_item, event)">
        <img src="{_item.favIconUrl||'chrome://favicon/'}" class="favicon">
        {_item.title}
      </a>
    {/each}
  {:else}
    <p class="muted">No matching Open Tabs</p>
  {/if}

  <!-- Bookmarks -->
  {#if _bookmarks.length}
    <h2>Bookmarks ({_bookmarks.length}/{_bookmarksRaw.length})</h2>

    {#each _bookmarks as _item (_item.id)}
      <a href="{_item.url}" class="result">
        <img src="chrome://favicon/{_item.url || ''}" class="favicon">
        {_item.title || _item.url}
      </a>
    {/each}

    {#if _bookmarks.length < _bookmarksRaw.length}
      <button on:click="_loadMoreBookmarks(_bookmarks.length)">Show more ▾</button>
    {/if}
  {:elseif _isSearching}
    <p class="muted">No matching Bookmarks</p>
  {/if}

  <!-- History -->
  {#if _history.length}
    <h2>History ({_history.length}/{_historyRaw.length})</h2>

    {#each _history as _item (_item.id)}
      <a href="{_item.url}" class="result">
        <img src="chrome://favicon/{_item.url || ''}" class="favicon">
        {_item.title || _item.url}
      </a>
    {/each}

    {#if _history.length < _historyRaw.length}
      <button on:click="_loadMoreHistory(_history.length)">Show more ▾</button>
    {/if}
  {:elseif _isSearching}
    <p class="muted">No matching History</p>
  {/if}

  <!-- Top Sites -->
  {#if _topSites.length}
    <h2>Top Sites ({_topSites.length}/{_topSitesRaw.length})</h2>

    {#each _topSites as _item (_item.url)}
      <a href="{_item.url}" class="result">
        <img src="chrome://favicon/{_item.url}" class="favicon">
        {_item.title}
      </a>
    {/each}
  {:elseif _isSearching}
    <p class="muted">No matching Top Sites</p>
  {/if}
</div>

<script>
  const SEARCH_DEBOUNCE_DELAY = 260; // ms
  const DEFAULT_RESULTS_AMOUNT = 10;
  const MORE_RESULTS_AMOUNT = 100;

  /**
   * Delay running a function until X ms have passed since its last call.
   * @see https://github.com/developit/decko/blob/master/src/decko.js
   * @param {Function} fn The function to debounce.
   * @param {Number} delay How long to wait for more function calls before executing
   * the function in milliseconds.
   * @returns {Function}
   */
  function debounce(fn, delay) {
    let args;
    let context;
    let timer;

    return function (...a) { // eslint-disable-line func-names
      args = a;
      context = this;

      if (!timer) {
        timer = setTimeout(() => {
          fn.apply(context, args);
          args = context = timer = null; // eslint-disable-line no-multi-assign
        }, delay);
      }
    };
  }

  /**
   * Search for matching title or URL.
   * NOTE: Search query is passed as `this` value.
   * @param {object} item
   * @returns {Boolean}
   */
  function searchFilter(item) {
    return item.title.toLowerCase().indexOf(this) > -1
      || item.url
        // remove URL protocol since it's unlikely to be searched for
        .replace(/^.*?:\/\//, '')
        .toLowerCase().indexOf(this) > -1;
  }

  export default {
    immutable: true, // be mindful during development

    data: () => ({
      _search: '',
      _bookmarksRaw: [],
      _bookmarks: [],
      _historyRaw: [],
      _history: [],
      _tabsRaw: [],
      _tabs: [],
      _topSites: [],
      _topSitesRaw: [],
    }),
    computed: {
      _isSearching: ({ _search }) => _search !== '',
    },

    oncreate() {
      const getTabs = () => this._getTabs();

      this._onSearch = debounce(this._doSearch, SEARCH_DEBOUNCE_DELAY);

      getTabs();

      chrome.topSites.get((sites) => {
        this.set({
          _topSites: sites,
          _topSitesRaw: sites,
        });
      });

      // update tab list on tab events
      chrome.tabs.onUpdated.addListener(getTabs);
      chrome.tabs.onRemoved.addListener(getTabs);
      chrome.tabs.onMoved.addListener(getTabs);
      chrome.tabs.onAttached.addListener(getTabs);
    },

    // FIXME: When search is active, rerun when tab events trigger and _getTabs() is run
    onstate({ changed, previous }) {
      if (previous !== undefined && changed._search !== undefined) {
        this._onSearch();
      }
    },

    methods: {
      _doSearch() { // eslint-disable-line consistent-return
        const { _search, _tabsRaw, _topSitesRaw } = this.get();

        // reset search when input is empty
        if (_search === '') {
          return this.set({
            _bookmarks: [],
            _history: [],
            _tabs: _tabsRaw,
            _topSites: _topSitesRaw,
          });
        }

        // search history (run first since it takes the longest)
        chrome.history.search({ text: _search }, (results) => {
          this.set({
            _historyRaw: results,
            _history: results.slice(0, DEFAULT_RESULTS_AMOUNT),
          });
        });

        // search bookmarks
        chrome.bookmarks.search(_search, (results) => {
          this.set({
            _bookmarksRaw: results,
            _bookmarks: results.slice(0, DEFAULT_RESULTS_AMOUNT),
          });
        });

        this.set({
          // search open tabs
          _tabs: _tabsRaw.filter(searchFilter, _search),
          // search top sites
          _topSites: _topSitesRaw.filter(searchFilter, _search),
        });
      },

      _getTabs() {
        chrome.tabs.query({}, (tabs) => {
          if (this.get()._search === '') {
            this.set({
              _tabs: tabs,
              _tabsRaw: tabs,
            });
          } else {
            this.set({ _tabsRaw: tabs });
          }
        });
      },

      _onTabClick(tab, event) {
        event.stopPropagation();
        event.preventDefault();

        // update current tab
        chrome.tabs.update(tab.id, { active: true });

        // switch active window if the tab isn't in the current window
        chrome.windows.getCurrent({}, (currentWindow) => {
          if (currentWindow.id !== tab.windowId) {
            chrome.windows.update(tab.windowId, { focused: true });
          }
        });

        // close this NTP
        chrome.tabs.getCurrent((currentTab) => {
          chrome.tabs.remove(currentTab.id);
        });
      },

      _cancelSearch(key) {
        if (key === 'Escape') {
          const { _tabsRaw, _topSitesRaw } = this.get();
          this.set({
            _search: '',
            _bookmarks: [],
            _history: [],
            _tabs: _tabsRaw,
            _topSites: _topSitesRaw,
          });
        }
      },

      _loadMoreBookmarks(length) {
        this.set({ _bookmarks: this.get()._bookmarksRaw.slice(0, length + MORE_RESULTS_AMOUNT) });
      },

      _loadMoreHistory(length) {
        this.set({ _history: this.get()._historyRaw.slice(0, length + MORE_RESULTS_AMOUNT) });
      },
    },
  };
</script>

<style type="text/postcss" global>
  .container {
    max-width: 800px;
    padding: 0 18px;
    margin: 0 auto;
  }

  .result {
    display: block;
    align-items: center;
    padding: 9px 0;
    overflow: hidden;
    color: var(--t);
    text-overflow: ellipsis;
    white-space: nowrap;

    & > .favicon {
      padding-right: 9px;
    }
  }

  button,
  #search {
    box-sizing: border-box;
    width: 100%;
    padding: 11px 20px;
    margin: 0 0 18px;
    font-size: 22px;
    color: var(--t);
    background: var(--c0);
    border: 0;
    box-shadow: var(--s);
  }

  /* search input placeholder */
  ::placeholder {
    color: var(--c2);
  }

  /* load more buttons */
  button {
    width: initial;
    margin-top: 9px;
    cursor: pointer;
  }
</style>
