<!--
  XXX: The h2 titles are implemented abnormally to get around a current Svelte
  limitation where it creates multiple text nodes instead of realising there's
  multiple text nodes that could be combined into one. Once Svelte has this
  optimisation these titles should be refactored.
-->

<div class="container">
  <input
    id="search"
    bind:value="_searchText"
    ref:s
    placeholder="Search browser…"
    autocomplete="off"
    on:keyup="_cancelSearch(event.key)"
  >

  {#each _order as _section}
    {#if _section === 'Open Tabs'}

      <!-- Open Tabs -->

      <h2>{`Open Tabs (${_tabs.length}/${_tabsRaw.length})`}</h2>

      {#each _tabs as _item}
        <!-- XXX: This is the same as <LinkItem> but with a click handler -->
        <a href="{_item.url}" title="{_item.title}" on:click="_onTabClick(_item, event)">
          <img src="chrome://favicon/{_item.url}">
          {_item.title}
        </a>
      {/each}
    {:elseif _section === 'Top Sites'}

      <!-- Top Sites -->

      <h2>{`Top Sites (${_topSites.length}/${_topSitesRaw.length})`}</h2>

      {#each _topSites as _item}
        <LinkItem _url="{_item.url}" _title="{_item.title}" />
      {/each}
    {:elseif _isSearching && _section === 'Bookmarks'}

      <!-- Bookmarks -->

      <h2>{`Bookmarks (${_bookmarks.length}/${_bookmarksRaw.length})`}</h2>

      {#each _bookmarks as _item}
        <LinkItem _url="{_item.url}" _title="{_item.title}" />
      {/each}

      {#if _bookmarks.length < _bookmarksRaw.length}
        <button on:click="_loadMoreBookmarks(_bookmarks.length)">Show more ▾</button>
      {/if}
    {:elseif _isSearching && _section === 'History'}

      <!-- History -->

      <h2>{`History (${_history.length}/${_historyRaw.length})`}</h2>

      {#each _history as _item}
        <LinkItem _url="{_item.url}" _title="{_item.title}" />
      {/each}

      {#if _history.length < _historyRaw.length}
        <button on:click="_loadMoreHistory(_history.length)">Show more ▾</button>
      {/if}
    {/if}
  {/each}
</div>

<script>
  import { DEFAULT_ORDER, debounce } from '../common.js';
  import LinkItem from './LinkItem.html';

  const SEARCH_DEBOUNCE_DELAY = 260; // ms
  const DEFAULT_RESULTS_AMOUNT = 10;
  const MORE_RESULTS_AMOUNT = 100;

  // URL protocol regex
  const protocol = /^.*?:\/\//;

  /**
   * Check for a matching title or URL.
   * @this {string} Search query
   * @param {{ title: string, url: string }} item
   * @returns {boolean}
   */
  function searchFilter({ title, url }) {
    return title.toLowerCase().indexOf(this) > -1
      // remove URL protocol since it's unlikely to be searched for
      || url.replace(protocol, '').toLowerCase().indexOf(this) > -1;
  }

  export default {
    components: {
      LinkItem,
    },
    data: () => ({
      _order: DEFAULT_ORDER,
      _searchText: '',
      _bookmarksRaw: [],
      _bookmarks: [],
      _historyRaw: [],
      _history: [],
      _tabsRaw: [],
      _tabs: [],
      _topSites: [],
      _topSitesRaw: [],
    }),
    computed: {
      _isSearching: ({ _searchText }) => !!_searchText,
    },

    oncreate() {
      chrome.storage.local.get(null, (settings) => {
        /* eslint-disable dot-notation */ // prevent closure mangling
        if (settings['o']) {
          this.set({ _order: settings['o'] });
        }
        /* eslint-enable */
      });

      const getTabs = () => this._getTabs();

      getTabs();

      chrome.topSites.get((sites) => {
        this.set({
          _topSites: sites,
          _topSitesRaw: sites,
        });
      });

      this._onSearch = debounce(this._search, SEARCH_DEBOUNCE_DELAY);

      // bring focus to search input when clicking anywhere on the page
      window.addEventListener('click', () => {
        this.refs.s.focus();
      });

      // update tab list on tab events
      chrome.tabs.onUpdated.addListener(getTabs);
      chrome.tabs.onRemoved.addListener(getTabs);
      chrome.tabs.onMoved.addListener(getTabs);
      chrome.tabs.onAttached.addListener(getTabs);
    },

    // FIXME: When search is active, rerun when tab events trigger and _getTabs() is run
    onstate({ changed, previous }) {
      if (!previous) return;

      if (changed._searchText) {
        this._onSearch();
      }
    },

    methods: {
      _search() { // eslint-disable-line consistent-return
        const { _searchText, _tabsRaw, _topSitesRaw } = this.get();

        // reset search when input is empty
        if (_searchText === '') {
          return this.set({
            _bookmarks: [],
            _history: [],
            _tabs: _tabsRaw,
            _topSites: _topSitesRaw,
          });
        }

        // search history (run first since it takes the longest)
        chrome.history.search({ text: _searchText }, (results) => {
          this.set({
            _historyRaw: results,
            _history: results.slice(0, DEFAULT_RESULTS_AMOUNT),
          });
        });

        // search bookmarks
        chrome.bookmarks.search(_searchText, (results) => {
          this.set({
            _bookmarksRaw: results,
            _bookmarks: results.slice(0, DEFAULT_RESULTS_AMOUNT),
          });
        });

        this.set({
          // search open tabs
          _tabs: _tabsRaw.filter(searchFilter, _searchText),
          // search top sites
          _topSites: _topSitesRaw.filter(searchFilter, _searchText),
        });
      },

      /**
       * Query the browser for a list of the currently open tabs.
       */
      _getTabs() {
        chrome.tabs.query({}, (tabs) => {
          if (this.get()._searchText === '') {
            this.set({
              _tabs: tabs,
              _tabsRaw: tabs,
            });
          } else {
            this.set({ _tabsRaw: tabs });
          }
        });
      },

      _onTabClick(tab, event) {
        event.preventDefault();

        // update current tab
        chrome.tabs.update(tab.id, { active: true });

        // switch active window if the tab isn't in the current window
        chrome.windows.getCurrent({}, (currentWindow) => {
          if (currentWindow.id !== tab.windowId) {
            chrome.windows.update(tab.windowId, { focused: true });
          }
        });

        // close this NTP
        chrome.tabs.getCurrent((currentTab) => {
          chrome.tabs.remove(currentTab.id);
        });
      },

      _cancelSearch(key) {
        if (key === 'Escape') {
          const { _tabsRaw, _topSitesRaw } = this.get();
          this.set({
            _searchText: '',
            _bookmarks: [],
            _history: [],
            _tabs: _tabsRaw,
            _topSites: _topSitesRaw,
          });
        }
      },

      _loadMoreBookmarks(length) {
        this.set({ _bookmarks: this.get()._bookmarksRaw.slice(0, length + MORE_RESULTS_AMOUNT) });
      },

      _loadMoreHistory(length) {
        this.set({ _history: this.get()._historyRaw.slice(0, length + MORE_RESULTS_AMOUNT) });
      },
    },
  };
</script>

<style type="text/postcss" global>
  .container {
    max-width: 800px;
    padding: 0 18px;
    margin: 0 auto;
  }

  button,
  #search {
    box-sizing: border-box;
    width: 100%;
    padding: 11px 20px;
    margin: 0 0 18px;
    font-size: 22px;
    color: var(--t);
    background: var(--c0);
    border: 0;
    box-shadow: var(--s);
  }

  /* search input placeholder */
  ::placeholder {
    color: var(--c2);
  }

  /* load more buttons */
  button {
    width: initial;
    margin-top: 9px;
    cursor: pointer;
  }
</style>
