<div class="container">
  <input
    id="search"
    bind:value="searchText"
    ref:s
    placeholder="Search browserâ€¦"
    autocomplete="off"
    on:keyup="cancelSearch(event.key)"
  >

  {#each resultsOrder as resultSection}
    {#if resultSection === 'Open Tabs'}
      <h2>{`Open Tabs (${tabsList.length}/${tabsRaw.length})`}</h2>

      {#each tabsList as _node}
        <!-- XXX: This is the same as <LinkItem> but with a click handler -->
        <a href="{_node.url}" title="{_node.title}" on:click="handleTabClick(_node, event)">
          <img src="chrome://favicon/{_node.url}" class="{_node.title ? 'pad' : ''}">
          {_node.title}
        </a>
      {/each}
    {:elseif resultSection === 'Top Sites'}
      <SearchResults
        resultsName="Top Sites"
        resultsList="{topSitesList}"
        resultsRaw="{topSitesRaw}"
      />
    {:elseif isSearching && resultSection === 'Bookmarks'}
      <SearchResults
        resultsName="Bookmarks"
        resultsList="{bookmarksList}"
        resultsRaw="{bookmarksRaw}"
      />
    {:elseif isSearching && resultSection === 'History'}
      <SearchResults
        resultsName="History"
        resultsList="{historyList}"
        resultsRaw="{historyRaw}"
      />
    {/if}
  {/each}
</div>

<script>
  import { DEFAULT_ORDER, debounce } from '../common.js';
  import LinkItem from './LinkItem.html';
  import SearchResults from './SearchResults.html';

  const SEARCH_DEBOUNCE_DELAY = 260; // ms
  const DEFAULT_RESULTS_AMOUNT = 10;

  // URL protocol regex
  const protocol = /^.*?:\/\//;

  /**
   * Check if either title or URL match a query.
   * @this {string} Search query
   * @param {{ title: string, url: string }} item
   * @return {boolean}
   */
  function searchFilter({ title, url }) {
    return title.toLowerCase().indexOf(this) > -1
      // remove URL protocol since it's unlikely to be searched for
      || url.replace(protocol, '').toLowerCase().indexOf(this) > -1;
  }

  export default {
    components: {
      LinkItem,
      SearchResults,
    },
    data: () => ({
      bookmarksList: [],
      bookmarksRaw: [],
      historyList: [],
      historyRaw: [],
      resultsOrder: DEFAULT_ORDER,
      searchText: '',
      tabsList: [],
      tabsRaw: [],
      topSitesList: [],
      topSitesRaw: [],
    }),
    computed: {
      isSearching: ({ searchText }) => !!searchText,
    },

    oncreate() {
      chrome.storage.local.get(null, (settings) => {
        /* eslint-disable dot-notation */ // prevent closure mangling
        if (settings['o']) {
          this.set({ resultsOrder: settings['o'] });
        }
        /* eslint-enable */
      });

      const getTabs = () => this.getTabs();

      getTabs();

      chrome.topSites.get((sites) => {
        this.set({
          topSitesList: sites,
          topSitesRaw: sites,
        });
      });

      this.onSearch = debounce(this.doSearch, SEARCH_DEBOUNCE_DELAY);

      // FIXME: Should this be removed? Does it add any value or is it confusing?
      // bring focus to search input when clicking anywhere on the page
      // document.addEventListener('click', () => {
      //   this.refs.s.focus();
      // });

      // update tab list on tab events
      chrome.tabs.onUpdated.addListener(getTabs);
      chrome.tabs.onRemoved.addListener(getTabs);
      chrome.tabs.onMoved.addListener(getTabs);
      chrome.tabs.onAttached.addListener(getTabs);
    },

    // TODO: When search is active, rerun when tab events trigger and getTabs() is run
    /** @return {void=} */
    onstate({ changed, previous }) {
      if (!previous) return;

      if (changed.searchText) {
        this.onSearch();
      }
    },

    /** @return {void=} */
    methods: {
      doSearch() { // xxeslint-disable-line consistent-return
        const { searchText, tabsRaw, topSitesRaw } = this.get();

        // reset search when input is empty
        if (searchText === '') {
          this.set({
            bookmarksList: [],
            historyList: [],
            tabsList: tabsRaw,
            topSitesList: topSitesRaw,
          });
          return;
        }

        // search history (run first since it takes the longest)
        chrome.history.search({ text: searchText }, (results) => {
          this.set({
            historyRaw: results,
            historyList: results.slice(0, DEFAULT_RESULTS_AMOUNT),
          });
        });

        // search bookmarks
        chrome.bookmarks.search(searchText, (results) => {
          this.set({
            bookmarksRaw: results,
            bookmarksList: results.slice(0, DEFAULT_RESULTS_AMOUNT),
          });
        });

        this.set({
          // search open tabs
          tabsList: tabsRaw.filter(searchFilter, searchText),
          // search top sites
          topSitesList: topSitesRaw.filter(searchFilter, searchText),
        });
      },

      /** Query the browser for a list of the currently open tabs. */
      getTabs() {
        chrome.tabs.query({}, (tabs) => {
          if (this.get().searchText === '') {
            this.set({
              tabsList: tabs,
              tabsRaw: tabs,
            });
          } else {
            this.set({ tabsRaw: tabs });
          }
        });
      },

      /**
       * @param {Tab} tab
       * @param {MouseEvent}
       */
      handleTabClick(tab, event) {
        event.preventDefault();

        // update current tab
        chrome.tabs.update(tab.id, { active: true });

        // switch active window if the tab isn't in the current window
        chrome.windows.getCurrent({}, (currentWindow) => {
          if (currentWindow.id !== tab.windowId) {
            chrome.windows.update(tab.windowId, { focused: true });
          }
        });

        // close this NTP
        chrome.tabs.getCurrent((currentTab) => {
          chrome.tabs.remove(currentTab.id);
        });
      },

      cancelSearch(key) {
        if (key === 'Escape') {
          const { tabsRaw, topSitesRaw } = this.get();
          this.set({
            searchText: '',
            bookmarksList: [],
            historyList: [],
            tabsList: tabsRaw,
            topSitesList: topSitesRaw,
          });
        }
      },
    },
  };
</script>

<style type="text/postcss">
  /* load more buttons */
  :global(button) {
    width: initial;
    margin-top: 9px;
    cursor: pointer;
  }

  :global(.container) {
    max-width: 800px;
    padding: 0 18px;
    margin: 0 auto;
  }

  /* stylelint-disable no-descending-specificity */
  :global(button),
  :global(#search) {
    box-sizing: border-box;
    width: 100%;
    padding: 11px 20px;
    margin: 0 0 18px;
    font-size: 22px;
    color: var(--t);
    background: var(--c2);
    border: 0;
    border-radius: 24px;
    outline: none;

    &:hover,
    &:focus {
      background: var(--c1);
    }
  }
  /* stylelint-enable */
</style>
